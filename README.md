# Amirka

Набор инструментов или татарский ножик в дополнение к Lodash :)
  

Буду благодарен за Ваши отзывы и замечания. Пишите мне в telegram https://t.me/mr_amirka .  
С любовью, Ваш mr.Amirka :)
  
   

Библиотека Amirka включает в себя:  
- Minimalist Notation (технология, оптимизирующая процесс верстки);  
- Deal (Отменяемый Promise c реализаций интерфейса cancel и progress);  
- прочие сомнительные штуки...  


### Почему всё находится в одной библиотеке?

1. Все функции находятся в составе одной библиотеки, потому как в ней многократно переиспользуются собственные функции.  
2. Мне было довольно быстро и легко разрабатывать и перерабатывать все эти функции в рамках одного проекта и одной экосистемы.  
3. Я сторонник такого подхода, в котором весь исходный код проекта опирается на единую фундаментальную базу. При таком подходе легче ориентироваться, и он не содержит в себе дублирующуюся имплементацию методов схожих по назначению в каждом отдельном автономном компоненте, увеличивающую суммарный объем исходного кода.
4. При необходимости Вы можете имортировать только необходимые файлы библиотеки.
 

## Minimalist Notation.

Minimalist Notation (MN) (минималистическая нотация) - это технология генерации стилей для элементов разметки, основанная на парсинге значений атрибутов в разметке. В текущей версии для веб-приложений генерация осуществляется непосредственно в СSS. Технология колоссально ускоряет процесс верстки и может использоваться дополнительно с традиционными технологиями, либо заменять их полностью.  

Преимущество перед традиционными технологиями CSS-препроцессинга в том, что разработчик избавляется от необходимости писать CSS. CSS генерируется автоматически на основании нотации и заданных разработчиком правил генерации стилей. Разработчику больше не нужно контролировать, какие стили используются в его разметке, а какие - нет, ибо отныне стили генерируются динамически только для того, что присутствуют в разметке. 


PS:   
Технология ориентирована на методологию Functional/Atomic CSS - не так давно меня просветили в теории.  
Валерий, СПАСИБО!  

По названию методологии намониторил подобные проекты: https://acss.io/ , https://www.npmjs.com/package/functional-css


PS: Если Вы верстаете по методологии Functional/Atomic CSS, то: 
* со временем Вы с первого взгляда понимаете смысл каждого класса в разметке;
* имеете возможность легко стандартизировать правила нотации и именования классов;
* разметку легко переиспользовать в новом проекте, если он предусматривает тот же базовый набор функциональных классов в CSS. 
* в случае внесения правок в дизайн, Вы будете менять разметку HTML, внося минимум правок в CSS.
* у Вас прямые руки - Вы не натыкаетесь на грабли с перекрытиями стилей;
* имеете возможность настроить Вашу систему сборки под автоматическую генерацию CSS из классов в разметке;
* не задаете громоздкие атрибуты длинным селекторам в каждом месте, где хотите, например, просто добавить плавность трансформации. В функциональном подходе это делается один раз, как в CSS-коде ниже:

```css
[m~='dn250'] {
  -khtml-transition-duration: 250ms !important;
  -ms-transition-duration: 250ms !important;
  -o-transition-duration: 250ms !important;
  -moz-transition-duration: 250ms !important;
  -webkit-transition-duration: 250ms !important;
  transition-duration: 250ms !important;
}
```   



PS: Если у Вас вызывает беспокойство, почему некоторые атрибуты имеют флаг ``` !important ```, то это обусловлено тем, что атомные классы должны быть более приоритетными, чем традиционные классы и сложные селекторы, так как применение атомных классов подразумевает более точечную кастомизацию разметки поверх других более общих правил CSS. Например, во флаге ``` !important ``` была необходимость когда я применял технологию ``` an ``` вместе с ``` Angular Material (MD)``` для корректировки и кастомизации внешнего вида некоторых элементов, так как стили комплексных селекторов из MD перекрывали стили an. Однако такой подход может создавать Вам грабли, если Вы захотите посредством JS динамически менять стиль элемента, на который распространяется действие флага ``` !important ``` из CSS. Поэтому этот нюанс стоит учитывать. Например, это предусмотрено в некоторых дефолтных правилах an генерации эссенций стилей. Вы можете добавить суффикс ``` -i ``` в конец имени эссенции:  
```css
[m~='dn250-i'] {
  -khtml-transition-duration: 250ms;
  -ms-transition-duration: 250ms;
  -o-transition-duration: 250ms;
  -moz-transition-duration: 250ms;
  -webkit-transition-duration: 250ms;
  transition-duration: 250ms;
}
```



Благодаря MN:
* СSS генерируется автоматически из наименований классов в разметке, и мы экономим время, избавив себя от написания "сатанинского" CSS-кода;
* у нас нет мертвого CSS-кода, ибо CSS генерируется только для той разметки, которая имеется.
* мы имеем возможность не обращаться на сервер за "тяжелыми" СSS-файлами, генерируя CSS в рантайме.
* при внесении правок в дизайн мы меняем только разметку HTML, не трогая СSS. 

Если же Вы хотите иметь возможность кастомизировать / менять тему Вашего приложения, подменяя один только CSS-файл, то ничто не мешает Вам делать это по методологии BEM naming convention, ограничиваясь кастомизаций цветовых схем, размеров шрифтов и прочих атрибутов, не требующих изменения самой разметки.  

Для целей кастомизации стилей разметки под определенную тему в MN предусмотрена возможность манипуляции глобальными CSS правилами в рантайме, например, так с конкретными селекторами:
```js
mn.css('.theme-bg', {
  backgroundColor: '#EEE'
});
mn.css('.theme-b', {
  borderColor: '#CCC'
});
```
или так с эссенциями:
```js
mn('theme-bg', {
  style: {
    backgroundColor: '#EEE'
  }
});
mn('theme-b', {
  style: {
    borderColor: '#CCC'
  }
});
```

PS: Если необходимо задать несколько альтернативных значений для одного атрибута по аналогии с оным в CSS:
```css
.theme-bg{
  background-color: #CCC;
  background-color: rgba(0,0,0,0.2);
}
```
Вы можете сделать так:
```js
mn.css('.theme-bg', {
  backgroundColor: [ '#CCC',  'rgba(0,0,0,0.2)' ]
});
```


Технология "Minimalist Notation" поддерживает:
* параметризуемую нотацию имен классов;
* параметризуемые состояния;
* контексты родительских/дочерних селекторов;
* контексты комплексных селекторов;
* контексты медиа-запросов
* группировки подстрок в нотации;
* синонимы состояний и медиа-запросов;
* наследование от эссенций стилей (расширение; аналог ``` @extend ``` в SASS) ;
* примеси эссенций (аналог ``` @include ``` в SASS);
* ассоциацию селекторов с эссенциями стилей; 
* манипуляция глобальными стилями CSS в рантайме.  



## Using Amirka

```
npm install amirka --save
```

```js
import {minimalistNotationProvider} from 'amirka/minimalist-notation';
import {styleProvider} from 'amirka/common/style-provider';
import {readyProvider} from 'amirka/common/ready-provider';
const ready = readyProvider(window);
const style = styleProvider(ready, document, 'an-styles', 'an.');
const mn = minimalistNotationProvider(style);

mn('dn', p => {
  if (p.camel || p.negative) return
  const num = p.num;
  if (num) {
    return {
      style: {transitionDuration: num + 'ms' + p.i}
    };
  }
  return {
    exts: [ 'dn250' + p.ni]
  };
});

mn('overlay', {
  style: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }
});

mn.checkAttrs.n = true;

ready(() => {
  mn
    .recursiveCheckNodeByAttr(document)
    .compile();
});
```


## For example:

```html
  <x m="f12 pd10 mg10b f14:h cF00<.parent c0F0@mediaName">...</x> 
```



Продолжение статьи в разработке... :(